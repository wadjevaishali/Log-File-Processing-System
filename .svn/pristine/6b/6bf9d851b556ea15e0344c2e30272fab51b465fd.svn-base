package com.logfileprocessing;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;

public class LogFileProcessorPnC {

	public static BlockingQueue<Data> ReaderProcessorQueue = new LinkedBlockingQueue<Data>();
	public static BlockingQueue<Data> ProcessorWriterQueue = new LinkedBlockingQueue<Data>();

	public static void main(String[] args) {
		try {

			new Thread(new Reader()).start();
			new Thread(new Processor()).start();
			new Thread(new Writer()).start();

		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class Data {
	Path path;
	List<String> lines;

	public Data(Path path, List<String> lines) {
		this.path = path;
		this.lines = lines;
	}
}

class Reader implements Runnable {

	DirectoryStream<Path> directoryStream = null;

	public Reader() {
		try {
			directoryStream = Files.newDirectoryStream(Paths
					.get("E:\\LogFiles"));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void run() {
		ExecutorService prodExecutor = Executors.newFixedThreadPool(10);
		List<Future<Data>> futureObjects = new ArrayList<Future<Data>>();

		for (Path path : directoryStream) {
			futureObjects.add(prodExecutor.submit(new Callable<Data>() {

				@Override
				public Data call() throws Exception {
					Data data = null;
					try {
						List<String> readLines = Files.readAllLines(path,
								StandardCharsets.UTF_8);
						data = new Data(path, readLines);
					} catch (IOException e) {
						e.printStackTrace();
					}

					return data;
				}
			}));
		}

		for (Future<Data> future : futureObjects) {
			try {
				System.out.println(future.get().path + " is reading.");
				LogFileProcessorPnC.ReaderProcessorQueue.put(future.get());
			} catch (InterruptedException | ExecutionException e) {
				e.printStackTrace();
			}
		}

		prodExecutor.shutdown();
	}
}

class Processor implements Runnable {

	static int count = 1;

	@Override
	public void run() {
		while (true) {
			Data data = null;
			try {
				data = LogFileProcessorPnC.ReaderProcessorQueue.take();
				System.out.println("processing " + data.path);
				for (int i = 0; i < data.lines.size(); i++) {
					StringBuilder sb = new StringBuilder();
					data.lines.set(
							i,
							sb.append(count++).append(".")
									.append(data.lines.get(i)).toString());
				}
				LogFileProcessorPnC.ProcessorWriterQueue.put(data);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}

class Writer implements Runnable {
	@Override
	public void run() {
		ExecutorService consExecutor = Executors.newFixedThreadPool(10);
		while (!LogFileProcessorPnC.ProcessorWriterQueue.isEmpty()) {
			consExecutor.execute(new Runnable() {
				@Override
				public void run() {
					try {
						Data data = LogFileProcessorPnC.ProcessorWriterQueue
								.take();
						System.out.println(data.path + " is writing.");
						Files.write(data.path, data.lines,
								StandardOpenOption.CREATE);
					} catch (IOException e) {
						e.printStackTrace();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			});
		}

		consExecutor.shutdown();
	}
}
